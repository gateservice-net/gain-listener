// automatically generated by the FlatBuffers compiler, do not modify



use std::mem;
use std::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::EndianScalar;

#[allow(non_camel_case_types)]
#[repr(i16)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum BindError {
  None = 0,
  TooManyBindings = 1,
  AlreadyBound = 2,
  InvalidAcceptSize = 3,
  InvalidName = 4,
  NameTooLong = 5,
  UnsupportedPort = 6,

}

const ENUM_MIN_BIND_ERROR: i16 = 0;
const ENUM_MAX_BIND_ERROR: i16 = 6;

impl<'a> flatbuffers::Follow<'a> for BindError {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for BindError {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = i16::to_le(self as i16);
    let p = &n as *const i16 as *const BindError;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = i16::from_le(self as i16);
    let p = &n as *const i16 as *const BindError;
    unsafe { *p }
  }
}

impl flatbuffers::Push for BindError {
    type Output = BindError;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<BindError>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_BIND_ERROR:[BindError; 7] = [
  BindError::None,
  BindError::TooManyBindings,
  BindError::AlreadyBound,
  BindError::InvalidAcceptSize,
  BindError::InvalidName,
  BindError::NameTooLong,
  BindError::UnsupportedPort
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_BIND_ERROR:[&'static str; 7] = [
    "None",
    "TooManyBindings",
    "AlreadyBound",
    "InvalidAcceptSize",
    "InvalidName",
    "NameTooLong",
    "UnsupportedPort"
];

pub fn enum_name_bind_error(e: BindError) -> &'static str {
  let index = e as i16;
  ENUM_NAMES_BIND_ERROR[index as usize]
}

#[allow(non_camel_case_types)]
#[repr(i16)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum AcceptError {
  None = 0,

}

const ENUM_MIN_ACCEPT_ERROR: i16 = 0;
const ENUM_MAX_ACCEPT_ERROR: i16 = 0;

impl<'a> flatbuffers::Follow<'a> for AcceptError {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for AcceptError {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = i16::to_le(self as i16);
    let p = &n as *const i16 as *const AcceptError;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = i16::from_le(self as i16);
    let p = &n as *const i16 as *const AcceptError;
    unsafe { *p }
  }
}

impl flatbuffers::Push for AcceptError {
    type Output = AcceptError;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<AcceptError>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_ACCEPT_ERROR:[AcceptError; 1] = [
  AcceptError::None
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_ACCEPT_ERROR:[&'static str; 1] = [
    "None"
];

pub fn enum_name_accept_error(e: AcceptError) -> &'static str {
  let index = e as i16;
  ENUM_NAMES_ACCEPT_ERROR[index as usize]
}

#[allow(non_camel_case_types)]
#[repr(i16)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum AcceptSize {
  Invalid = 0,
  Basic = 44,

}

const ENUM_MIN_ACCEPT_SIZE: i16 = 0;
const ENUM_MAX_ACCEPT_SIZE: i16 = 44;

impl<'a> flatbuffers::Follow<'a> for AcceptSize {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for AcceptSize {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = i16::to_le(self as i16);
    let p = &n as *const i16 as *const AcceptSize;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = i16::from_le(self as i16);
    let p = &n as *const i16 as *const AcceptSize;
    unsafe { *p }
  }
}

impl flatbuffers::Push for AcceptSize {
    type Output = AcceptSize;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<AcceptSize>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_ACCEPT_SIZE:[AcceptSize; 2] = [
  AcceptSize::Invalid,
  AcceptSize::Basic
];

#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum Function {
  NONE = 0,
  BindTLS = 1,

}

const ENUM_MIN_FUNCTION: u8 = 0;
const ENUM_MAX_FUNCTION: u8 = 1;

impl<'a> flatbuffers::Follow<'a> for Function {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for Function {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const Function;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const Function;
    unsafe { *p }
  }
}

impl flatbuffers::Push for Function {
    type Output = Function;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<Function>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_FUNCTION:[Function; 2] = [
  Function::NONE,
  Function::BindTLS
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_FUNCTION:[&'static str; 2] = [
    "NONE",
    "BindTLS"
];

pub fn enum_name_function(e: Function) -> &'static str {
  let index = e as u8;
  ENUM_NAMES_FUNCTION[index as usize]
}

pub struct FunctionUnionTableOffset {}
// struct IPAddr, aligned to 4
#[repr(C, align(4))]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct IPAddr {
  a_: u32,
  b_: u32,
  c_: u32,
  d_: u32,
} // pub struct IPAddr
impl flatbuffers::SafeSliceAccess for IPAddr {}
impl<'a> flatbuffers::Follow<'a> for IPAddr {
  type Inner = &'a IPAddr;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a IPAddr>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a IPAddr {
  type Inner = &'a IPAddr;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<IPAddr>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for IPAddr {
    type Output = IPAddr;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(self as *const IPAddr as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}
impl<'b> flatbuffers::Push for &'b IPAddr {
    type Output = IPAddr;

    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(*self as *const IPAddr as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}


impl IPAddr {
  pub fn new<'a>(_a: u32, _b: u32, _c: u32, _d: u32) -> Self {
    IPAddr {
      a_: _a.to_little_endian(),
      b_: _b.to_little_endian(),
      c_: _c.to_little_endian(),
      d_: _d.to_little_endian(),

    }
  }
  pub fn a<'a>(&'a self) -> u32 {
    self.a_.from_little_endian()
  }
  pub fn b<'a>(&'a self) -> u32 {
    self.b_.from_little_endian()
  }
  pub fn c<'a>(&'a self) -> u32 {
    self.c_.from_little_endian()
  }
  pub fn d<'a>(&'a self) -> u32 {
    self.d_.from_little_endian()
  }
}

// struct AcceptBasic, aligned to 4
#[repr(C, align(4))]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct AcceptBasic {
  error_: AcceptError,
  padding0__: u16,
  conn_id_: i32,
  addr_: IPAddr,
  port_: u16,
  padding1__: u16,
} // pub struct AcceptBasic
impl flatbuffers::SafeSliceAccess for AcceptBasic {}
impl<'a> flatbuffers::Follow<'a> for AcceptBasic {
  type Inner = &'a AcceptBasic;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a AcceptBasic>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a AcceptBasic {
  type Inner = &'a AcceptBasic;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<AcceptBasic>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for AcceptBasic {
    type Output = AcceptBasic;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(self as *const AcceptBasic as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}
impl<'b> flatbuffers::Push for &'b AcceptBasic {
    type Output = AcceptBasic;

    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(*self as *const AcceptBasic as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}


impl AcceptBasic {
  pub fn new<'a>(_error: AcceptError, _conn_id: i32, _addr: &'a IPAddr, _port: u16) -> Self {
    AcceptBasic {
      error_: _error.to_little_endian(),
      conn_id_: _conn_id.to_little_endian(),
      addr_: *_addr,
      port_: _port.to_little_endian(),

      padding0__: 0,
      padding1__: 0,
    }
  }
  pub fn error<'a>(&'a self) -> AcceptError {
    self.error_.from_little_endian()
  }
  pub fn conn_id<'a>(&'a self) -> i32 {
    self.conn_id_.from_little_endian()
  }
  pub fn addr<'a>(&'a self) -> &'a IPAddr {
    &self.addr_
  }
  pub fn port<'a>(&'a self) -> u16 {
    self.port_.from_little_endian()
  }
}

pub enum AcceptOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Accept<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Accept<'a> {
    type Inner = Accept<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Accept<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Accept {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args AcceptArgs<'args>) -> flatbuffers::WIPOffset<Accept<'bldr>> {
      let mut builder = AcceptBuilder::new(_fbb);
      if let Some(x) = args.basic { builder.add_basic(x); }
      builder.finish()
    }

    pub const VT_BASIC: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn basic(&self) -> Option<&'a AcceptBasic> {
    self._tab.get::<AcceptBasic>(Accept::VT_BASIC, None)
  }
}

pub struct AcceptArgs<'a> {
    pub basic: Option<&'a  AcceptBasic>,
}
impl<'a> Default for AcceptArgs<'a> {
    #[inline]
    fn default() -> Self {
        AcceptArgs {
            basic: None,
        }
    }
}
pub struct AcceptBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> AcceptBuilder<'a, 'b> {
  #[inline]
  pub fn add_basic(&mut self, basic: &'b  AcceptBasic) {
    self.fbb_.push_slot_always::<&AcceptBasic>(Accept::VT_BASIC, basic);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> AcceptBuilder<'a, 'b> {
    let start = _fbb.start_table();
    AcceptBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Accept<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum BindTLSOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct BindTLS<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BindTLS<'a> {
    type Inner = BindTLS<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> BindTLS<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        BindTLS {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args BindTLSArgs<'args>) -> flatbuffers::WIPOffset<BindTLS<'bldr>> {
      let mut builder = BindTLSBuilder::new(_fbb);
      if let Some(x) = args.name { builder.add_name(x); }
      builder.add_port(args.port);
      builder.add_accept_size(args.accept_size);
      builder.finish()
    }

    pub const VT_ACCEPT_SIZE: flatbuffers::VOffsetT = 4;
    pub const VT_NAME: flatbuffers::VOffsetT = 6;
    pub const VT_PORT: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn accept_size(&self) -> AcceptSize {
    self._tab.get::<AcceptSize>(BindTLS::VT_ACCEPT_SIZE, Some(AcceptSize::Invalid)).unwrap()
  }
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BindTLS::VT_NAME, None)
  }
  #[inline]
  pub fn port(&self) -> u16 {
    self._tab.get::<u16>(BindTLS::VT_PORT, Some(0)).unwrap()
  }
}

pub struct BindTLSArgs<'a> {
    pub accept_size: AcceptSize,
    pub name: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub port: u16,
}
impl<'a> Default for BindTLSArgs<'a> {
    #[inline]
    fn default() -> Self {
        BindTLSArgs {
            accept_size: AcceptSize::Invalid,
            name: None,
            port: 0,
        }
    }
}
pub struct BindTLSBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BindTLSBuilder<'a, 'b> {
  #[inline]
  pub fn add_accept_size(&mut self, accept_size: AcceptSize) {
    self.fbb_.push_slot::<AcceptSize>(BindTLS::VT_ACCEPT_SIZE, accept_size, AcceptSize::Invalid);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BindTLS::VT_NAME, name);
  }
  #[inline]
  pub fn add_port(&mut self, port: u16) {
    self.fbb_.push_slot::<u16>(BindTLS::VT_PORT, port, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BindTLSBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BindTLSBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BindTLS<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum BindingOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Binding<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Binding<'a> {
    type Inner = Binding<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Binding<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Binding {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args BindingArgs<'args>) -> flatbuffers::WIPOffset<Binding<'bldr>> {
      let mut builder = BindingBuilder::new(_fbb);
      if let Some(x) = args.host { builder.add_host(x); }
      builder.add_listen_id(args.listen_id);
      builder.add_port(args.port);
      builder.add_error(args.error);
      builder.finish()
    }

    pub const VT_ERROR: flatbuffers::VOffsetT = 4;
    pub const VT_LISTEN_ID: flatbuffers::VOffsetT = 6;
    pub const VT_HOST: flatbuffers::VOffsetT = 8;
    pub const VT_PORT: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn error(&self) -> BindError {
    self._tab.get::<BindError>(Binding::VT_ERROR, Some(BindError::None)).unwrap()
  }
  #[inline]
  pub fn listen_id(&self) -> i32 {
    self._tab.get::<i32>(Binding::VT_LISTEN_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn host(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Binding::VT_HOST, None)
  }
  #[inline]
  pub fn port(&self) -> u16 {
    self._tab.get::<u16>(Binding::VT_PORT, Some(0)).unwrap()
  }
}

pub struct BindingArgs<'a> {
    pub error: BindError,
    pub listen_id: i32,
    pub host: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub port: u16,
}
impl<'a> Default for BindingArgs<'a> {
    #[inline]
    fn default() -> Self {
        BindingArgs {
            error: BindError::None,
            listen_id: 0,
            host: None,
            port: 0,
        }
    }
}
pub struct BindingBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BindingBuilder<'a, 'b> {
  #[inline]
  pub fn add_error(&mut self, error: BindError) {
    self.fbb_.push_slot::<BindError>(Binding::VT_ERROR, error, BindError::None);
  }
  #[inline]
  pub fn add_listen_id(&mut self, listen_id: i32) {
    self.fbb_.push_slot::<i32>(Binding::VT_LISTEN_ID, listen_id, 0);
  }
  #[inline]
  pub fn add_host(&mut self, host: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Binding::VT_HOST, host);
  }
  #[inline]
  pub fn add_port(&mut self, port: u16) {
    self.fbb_.push_slot::<u16>(Binding::VT_PORT, port, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BindingBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BindingBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Binding<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum CallOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Call<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Call<'a> {
    type Inner = Call<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Call<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Call {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args CallArgs) -> flatbuffers::WIPOffset<Call<'bldr>> {
      let mut builder = CallBuilder::new(_fbb);
      if let Some(x) = args.function { builder.add_function(x); }
      builder.add_function_type(args.function_type);
      builder.finish()
    }

    pub const VT_FUNCTION_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_FUNCTION: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn function_type(&self) -> Function {
    self._tab.get::<Function>(Call::VT_FUNCTION_TYPE, Some(Function::NONE)).unwrap()
  }
  #[inline]
  pub fn function(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Call::VT_FUNCTION, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn function_as_bind_tls(&self) -> Option<BindTLS<'a>> {
    if self.function_type() == Function::BindTLS {
      self.function().map(|u| BindTLS::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct CallArgs {
    pub function_type: Function,
    pub function: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for CallArgs {
    #[inline]
    fn default() -> Self {
        CallArgs {
            function_type: Function::NONE,
            function: None,
        }
    }
}
pub struct CallBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CallBuilder<'a, 'b> {
  #[inline]
  pub fn add_function_type(&mut self, function_type: Function) {
    self.fbb_.push_slot::<Function>(Call::VT_FUNCTION_TYPE, function_type, Function::NONE);
  }
  #[inline]
  pub fn add_function(&mut self, function: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Call::VT_FUNCTION, function);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CallBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CallBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Call<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

